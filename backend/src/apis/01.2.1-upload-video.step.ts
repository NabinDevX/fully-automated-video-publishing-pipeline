import type { ApiRouteConfig, Handlers } from "motia";
import { randomUUID } from "crypto";
import { Readable } from "stream";
import { connectMongo } from "../db/index";
import { uploadVideo } from "../shared/storage";
import { isValidVideoFormat, formatFileSize } from "../shared/storage-utils";

export const config: ApiRouteConfig = {
  name: "Upload-File",
  type: "api",
  path: "/upload",
  method: "POST",
  description: "Upload a video file to S3 and process it",
  flows: ["yt.video.upload"],
  emits: [
    { topic: "file.uploaded", label: "File Uploaded" },
    { topic: "file.upload.error", label: "File Uploading Failed", conditional: true },
  ],
};

export const handler: Handlers["Upload-File"] = async (
  req: any,
  { emit, logger, state }: any
) => {
  await connectMongo();
  const traceId = randomUUID();

  try {
    const file = req.files?.file;

    if (!file) {
      return {
        status: 400,
        body: { error: "File is required" },
      };
    }

    if (!isValidVideoFormat(file.originalname)) {
      return {
        status: 400,
        body: {
          error: "Invalid video format. Supported formats: mp4, mov, avi, webm, mkv"
        },
      };
    }

    const title = req.body?.title || "";
    const description = req.body?.description || "";
    const tags = req.body?.tags || "";
    const privacy = req.body?.privacy || "private";
    const autoGenerateTitle = req.body?.autoGenerateTitle === "true";
    const autoGenerateDescription = req.body?.autoGenerateDescription === "true";

    logger.info("Received video file", {
      traceId,
      name: file.originalname,
      size: formatFileSize(file.size),
      mimetype: file.mimetype,
    });

    const videoStream = Readable.from(file.buffer);

    logger.info("Uploading video to S3", { traceId });

    const { storageKey, url, format } = await uploadVideo(
      videoStream,
      file.originalname
    );

    logger.info("Video uploaded to S3", {
      traceId,
      storageKey,
      url,
      format,
    });

    await state.set(traceId, "videoData", {
      fileName: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      format,
      storageKey,
      url,
    });

    await state.set(traceId, "metadata", {
      title,
      description,
      tags: tags.split(",").map((t: string) => t.trim()).filter(Boolean),
      privacy,
      autoGenerateTitle,
      autoGenerateDescription,
    });

    await state.set(traceId, "status", {
      status: "pending",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    });

    await emit({
      topic: "file.uploaded",
      data: {
        traceId,
        fileName: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        storageKey,
        url,
        format,
      },
    });

    logger.info("File uploaded and state saved", { traceId, storageKey });

    return {
      status: 200,
      body: {
        success: true,
        message: "Video uploaded successfully",
        traceId,
        storageKey,
        url,
      },
    };
  } catch (error: any) {
    logger.error("Error uploading file", { traceId, error: error.message });

    // Update status in state
    try {
      await state.set(traceId, "status", {
        status: "failed",
        error: error.message,
        updatedAt: new Date().toISOString(),
      });
    } catch {
      // Ignore state error
    }

    await emit({
      topic: "file.upload.error",
      data: { traceId, error: error.message },
    });

    return {
      status: 500,
      body: { error: "Internal server error", traceId },
    };
  }
};

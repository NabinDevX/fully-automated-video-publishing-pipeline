import type { ApiRouteConfig, Handlers } from "motia";
import { randomUUID } from "crypto";

export const config: ApiRouteConfig = {
  name: "Upload-File",
  type: "api",
  path: "/upload",
  method: "POST",
  description: "Upload a file and process it",
  flows: ["yt.video.upload"],
  emits: [
    { topic: "file.uploaded", label: "File Uploaded" },
    { topic: "file.upload.error", label: "File Uploading Failed", conditional: true },
  ],
};

export const handler: Handlers["Upload-File"] = async (
  req: any,
  { emit, logger, state }: any
) => {
  const traceId = randomUUID();

  try {
    const file = req.files?.file;

    if (!file) {
      return {
        status: 400,
        body: { error: "File is required" },
      };
    }

    // Extract form data
    const title = req.body?.title || "";
    const description = req.body?.description || "";
    const tags = req.body?.tags || "";
    const privacy = req.body?.privacy || "private";
    const autoGenerateTitle = req.body?.autoGenerateTitle === "true";
    const autoGenerateDescription = req.body?.autoGenerateDescription === "true";

    logger.info("Received file", {
      traceId,
      name: file.originalname,
      size: file.size,
      mimetype: file.mimetype,
    });

    // Store video data in state
    await state.set(traceId, "videoData", {
      fileName: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      buffer: file.buffer.toString("base64"), // Store buffer as base64
    });

    // Store metadata in state
    await state.set(traceId, "metadata", {
      title,
      description,
      tags: tags.split(",").map((t: string) => t.trim()).filter(Boolean),
      privacy,
      autoGenerateTitle,
      autoGenerateDescription,
    });

    // Store upload status in state
    await state.set(traceId, "status", {
      status: "pending",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    });

    // Emit event with traceId only (data is in state)
    await emit({
      topic: "file.uploaded",
      data: {
        traceId,
        fileName: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
      },
    });

    logger.info("File uploaded and state saved", { traceId });

    return {
      status: 200,
      body: {
        success: true,
        message: "File uploaded successfully",
        traceId,
      },
    };
  } catch (error: any) {
    logger.error("Error uploading file", { traceId, error: error.message });

    // Update status in state if traceId exists
    try {
      await state.set(traceId, "status", {
        status: "failed",
        error: error.message,
        updatedAt: new Date().toISOString(),
      });
    } catch {
      // Ignore state error
    }

    await emit({
      topic: "file.upload.error",
      data: { traceId, error: error.message },
    });

    return {
      status: 500,
      body: { error: "Internal server error", traceId },
    };
  }
};
